{"version":3,"file":"record_processor.js","sourceRoot":"","sources":["../../../../src/utils/federation/processors/record_processor.ts"],"names":[],"mappings":";;AAYA,oDAwBC;AAYD,sCA6BC;AA3ED,2DAA6D;AAE7D,uDAAmE,CAAC,mBAAmB;AAEvF;;;;;EAKE;AACF,SAAgB,oBAAoB,CAClC,YAAiC,EACjC,MAA2B;;IAE3B,MAAM,MAAM,GAAwB,EAAE,CAAC;IACvC,IAAI,SAAS,GAAG,KAAK,CAAC,CAAC,+CAA+C;IAEtE,KAAK,MAAM,CAAC,SAAS,EAAE,SAAS,CAAC,IAAI,MAAM,EAAE,CAAC;QAC5C,MAAM,gBAAgB,GAAG,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC,+CAA+C;QAEjG,8EAA8E;QAC9E,IAAI,gBAAgB,KAAK,SAAS,EAAE,CAAC;YACnC,MAAM,CAAC,SAAS,CAAC,GAAG,gBAAgB,CAAC,CAAC,4DAA4D;YAElG,uEAAuE;YACvE,MAAM,WAAW,GAAG,MAAA,gBAAgB,aAAhB,gBAAgB,uBAAhB,gBAAgB,CAAE,KAAK,mCAAI,gBAAgB,CAAC,CAAC,gCAAgC;YACjG,IAAG,WAAW,KAAK,SAAS,IAAI,WAAW,KAAK,IAAI,IAAI,WAAW,KAAK,EAAE,EAAE,CAAC;gBAC3E,SAAS,GAAG,IAAI,CAAC;YACnB,CAAC;QACH,CAAC;IACH,CAAC;IAED,8DAA8D;IAC9D,OAAO,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC;AACxD,CAAC;AAGD;;;;;;;;EAQE;AACF,SAAgB,aAAa,CAC3B,YAAiC,EACjC,eAAuB,EACvB,OAAsB;IAEtB,MAAM,MAAM,GAA0B,EAAE,CAAC;IAEzC,IAAI,CAAC;QACH,IAAI,OAAO,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;YAC/B,MAAM,gBAAgB,GAAG,IAAA,0CAAsB,EAC7C,YAAY,EACZ,eAAe,EACf,OAAO,CAAC,aAAa,EACrB,OAAO,CAAC,gBAAgB,CACzB,CAAC;YACF,IAAI,gBAAgB,IAAI,gBAAgB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACpD,MAAM,CAAC,IAAI,CAAC,GAAG,gBAAgB,CAAC,CAAC;YACnC,CAAC;QACH,CAAC;aAAM,CAAC;YACN,MAAM,cAAc,GAAG,oBAAoB,CAAC,YAAY,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;YAC1E,IAAI,cAAc,EAAE,CAAC;gBACnB,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;YAC9B,CAAC;QACH,CAAC;IACH,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,IAAA,sBAAQ,EAAC,qBAAqB,EAAE,4CAA4C,OAAO,CAAC,IAAI,kBAAkB,OAAO,CAAC,SAAS,KAAK,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;IAC5L,CAAC;IAED,OAAO,MAAM,CAAC;AAChB,CAAC","sourcesContent":["// src/utils/federation/processors/record_processor.ts\nimport { Flatfile } from \"@flatfile/api\";\nimport { createUnpivotedRecords } from \"./unpivot_processor\";\nimport { SourceMapping, FieldMapping, UnpivotMapping } from \"../../../types\"; // Ensure correct import path\nimport { logError, logInfo, logWarn } from \"@flatfile/util-common\"; // Optional logging\n\n/**\n* Creates a standard record by mapping source fields to target fields (including virtual)\n* @param recordValues - The source record values { fieldKey: { value: any } }\n* @param fields - Map of source field keys to target/virtual field keys\n* @returns The mapped record or null if no valid mappings or if all values are empty\n*/\nexport function createStandardRecord(\n  recordValues: Record<string, any>,\n  fields: Map<string, string>\n): Flatfile.RecordData | null {\n  const result: Flatfile.RecordData = {};\n  let hasValues = false; // Track if any non-null/empty value was mapped\n  \n  for (const [sourceKey, targetKey] of fields) {\n    const sourceFieldValue = recordValues[sourceKey]; // This might be { value: ... } or direct value\n    \n    // Add the field if the source key exists, even if its value is null/undefined\n    if (sourceFieldValue !== undefined) {\n      result[targetKey] = sourceFieldValue; // Copy the whole value object { value: ...} or direct value\n      \n      // Check if the mapped value is considered non-empty for hasValues flag\n      const actualValue = sourceFieldValue?.value ?? sourceFieldValue; // Get primitive value if exists\n      if(actualValue !== undefined && actualValue !== null && actualValue !== '') {\n        hasValues = true;\n      }\n    }\n  }\n  \n  // Return the record if it has any keys mapped, otherwise null\n  return Object.keys(result).length > 0 ? result : null;\n}\n\n\n/**\n* Processes a record based on the mapping configuration.\n* - For 'field' type: Maps source fields to target/virtual fields.\n* - For 'unpivot' type: Creates unpivoted records and attaches virtual fields to each.\n* @param recordValues - The source record values { fieldKey: { value: any } }\n* @param sourceSheetSlug - The source sheet slug (for logging/debugging)\n* @param mapping - The source mapping configuration (FieldMapping or UnpivotMapping)\n* @returns Array of processed records\n*/\nexport function processRecord(\n  recordValues: Record<string, any>,\n  sourceSheetSlug: string,\n  mapping: SourceMapping\n): Flatfile.RecordData[] {\n  const result: Flatfile.RecordData[] = [];\n  \n  try {\n    if (mapping.type === 'unpivot') {\n      const unpivotedRecords = createUnpivotedRecords(\n        recordValues,\n        sourceSheetSlug,\n        mapping.unpivotGroups,\n        mapping.virtualFieldsMap \n      );\n      if (unpivotedRecords && unpivotedRecords.length > 0) {\n        result.push(...unpivotedRecords);\n      }\n    } else { \n      const standardRecord = createStandardRecord(recordValues, mapping.fields);\n      if (standardRecord) {\n        result.push(standardRecord);\n      }\n    }\n  } catch (error) {\n    logError(\"ðŸ“¦ Record Processor\", `Error processing record for mapping type ${mapping.type}, target sheet ${mapping.sheetSlug}: ${error instanceof Error ? error.message : String(error)}`);\n  }\n  \n  return result;\n}"]}