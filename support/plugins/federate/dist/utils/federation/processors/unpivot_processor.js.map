{"version":3,"file":"unpivot_processor.js","sourceRoot":"","sources":["../../../../src/utils/federation/processors/unpivot_processor.ts"],"names":[],"mappings":";;AAcA,wDAmEC;AA5ED;;;;;;;;EAQE;AACF,SAAgB,sBAAsB,CACpC,YAAiC,EACjC,UAAkB,EAClB,aAAkD,EAClD,gBAAsC;IAGtC,sCAAsC;IACtC,IAAI,CAAC,YAAY,EAAE,CAAC;QAClB,OAAO,EAAE,CAAC;IACZ,CAAC;IAED,MAAM,qBAAqB,GAA0B,EAAE,CAAC;IAExD,6BAA6B;IAC7B,MAAM,gBAAgB,GAAwB,EAAE,CAAC;IACjD,IAAI,cAAc,GAAG,KAAK,CAAC;IAC3B,IAAI,gBAAgB,IAAI,gBAAgB,CAAC,IAAI,GAAG,CAAC,EAAE,CAAC;QAClD,KAAK,MAAM,CAAC,SAAS,EAAE,UAAU,CAAC,IAAI,gBAAgB,EAAE,CAAC;YACvD,IAAI,YAAY,CAAC,SAAS,CAAC,KAAK,SAAS,IAAI,YAAY,CAAC,SAAS,CAAC,KAAK,IAAI,EAAE,CAAC;gBAC9E,gBAAgB,CAAC,UAAU,CAAC,GAAG,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC,uCAAuC;gBAC/F,cAAc,GAAG,IAAI,CAAC;YACxB,CAAC;QACH,CAAC;IACH,CAAC;IAED,yBAAyB;IACzB,KAAK,MAAM,CAAC,QAAQ,EAAE,KAAK,CAAC,IAAI,aAAa,EAAE,CAAC;QAC9C,IAAI,CAAC,KAAK,CAAC,cAAc,IAAI,KAAK,CAAC,cAAc,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC/D,SAAS;QACX,CAAC;QAED,uDAAuD;QACvD,KAAK,MAAM,OAAO,IAAI,KAAK,CAAC,cAAc,EAAE,CAAC;YAC3C,MAAM,iBAAiB,GAAwB,EAAE,CAAC;YAClD,IAAI,qBAAqB,GAAG,KAAK,CAAC;YAElC,sCAAsC;YACtC,KAAK,MAAM,CAAC,SAAS,EAAE,mBAAmB,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC;gBACvE,IAAI,OAAO,mBAAmB,KAAK,QAAQ,EAAE,CAAC;oBAC5C,SAAS;gBACX,CAAC;gBAED,IAAI,mBAAmB,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,mBAAmB,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC;oBAC/E,MAAM,WAAW,GAAG,mBAAmB,CAAC,SAAS,CAAC,CAAC,EAAE,mBAAmB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;oBACrF,iBAAiB,CAAC,SAAS,CAAC,GAAG,EAAE,KAAK,EAAE,WAAW,EAAE,CAAC;oBACtD,qBAAqB,GAAG,IAAI,CAAC;gBAC/B,CAAC;qBAAM,IAAI,YAAY,CAAC,mBAAmB,CAAC,KAAK,SAAS,IAAI,YAAY,CAAC,mBAAmB,CAAC,KAAK,IAAI,EAAE,CAAC;oBACzG,iBAAiB,CAAC,SAAS,CAAC,GAAG,YAAY,CAAC,mBAAmB,CAAC,CAAC;oBACjE,qBAAqB,GAAG,IAAI,CAAC;gBAC/B,CAAC;YACH,CAAC;YAED,kDAAkD;YAClD,IAAI,qBAAqB,EAAE,CAAC;gBAC1B,wDAAwD;gBACxD,MAAM,WAAW,GAAG,cAAc;oBAClC,CAAC,CAAC,EAAE,GAAG,iBAAiB,EAAE,GAAG,gBAAgB,EAAE;oBAC/C,CAAC,CAAC,iBAAiB,CAAC;gBAEpB,qBAAqB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YAC1C,CAAC;iBAAM,CAAC;YACR,CAAC;QACH,CAAC;IACH,CAAC;IAED,OAAO,qBAAqB,CAAC;AAC/B,CAAC","sourcesContent":["// src/utils/federation/processors/unpivot_processor.ts\nimport { Flatfile } from \"@flatfile/api\";\nimport { UnpivotGroupConfig } from \"../../../types\";\nimport { logInfo, logWarn, logError } from \"@flatfile/util-common\";\n\n/**\n* Creates unpivoted records from a source record according to unpivot configuration,\n* AND attaches virtual fields to each created record.\n* @param sourceRecord - Source record data { fieldKey: { value: any } }\n* @param sourceSlug - Source sheet slug (for logging/debugging)\n* @param unpivotGroups - Array of unpivot groups defining transformations\n* @param virtualFieldsMap - Optional map of source_key -> virtual_key for virtual fields\n* @returns Array of unpivoted records, each potentially including virtual fields\n*/\nexport function createUnpivotedRecords(\n  sourceRecord: Flatfile.RecordData,\n  sourceSlug: string,\n  unpivotGroups: Array<[string, UnpivotGroupConfig]>,\n  virtualFieldsMap?: Map<string, string> \n): Flatfile.RecordData[] {\n  \n  // Defend against null/undefined input\n  if (!sourceRecord) {\n    return [];\n  }\n  \n  const finalUnpivotedRecords: Flatfile.RecordData[] = [];\n  \n  // Prepare virtual field data\n  const virtualFieldData: Flatfile.RecordData = {};\n  let hasVirtualData = false;\n  if (virtualFieldsMap && virtualFieldsMap.size > 0) {\n    for (const [sourceKey, virtualKey] of virtualFieldsMap) {\n      if (sourceRecord[sourceKey] !== undefined && sourceRecord[sourceKey] !== null) {\n        virtualFieldData[virtualKey] = sourceRecord[sourceKey]; // Copy the value object { value: ... }\n        hasVirtualData = true;\n      }\n    }\n  }\n  \n  // Process unpivot groups\n  for (const [groupKey, group] of unpivotGroups) {\n    if (!group.field_mappings || group.field_mappings.length === 0) {\n      continue;\n    }\n    \n    // Process each transformation mapping within the group\n    for (const mapping of group.field_mappings) {\n      const baseUnpivotRecord: Flatfile.RecordData = {};\n      let hasValidUnpivotValues = false;\n      \n      // Create the base unpivoted structure\n      for (const [targetKey, sourceOrStaticValue] of Object.entries(mapping)) {\n        if (typeof sourceOrStaticValue !== 'string') {\n          continue;\n        }\n        \n        if (sourceOrStaticValue.startsWith('<<') && sourceOrStaticValue.endsWith('>>')) {\n          const staticValue = sourceOrStaticValue.substring(2, sourceOrStaticValue.length - 2);\n          baseUnpivotRecord[targetKey] = { value: staticValue };\n          hasValidUnpivotValues = true;\n        } else if (sourceRecord[sourceOrStaticValue] !== undefined && sourceRecord[sourceOrStaticValue] !== null) {\n          baseUnpivotRecord[targetKey] = sourceRecord[sourceOrStaticValue];\n          hasValidUnpivotValues = true;\n        }\n      }\n      \n      // Only add if the unpivot mapping yielded results\n      if (hasValidUnpivotValues) {\n        // Combine base unpivoted record with virtual field data\n        const finalRecord = hasVirtualData\n        ? { ...baseUnpivotRecord, ...virtualFieldData }\n        : baseUnpivotRecord;\n        \n        finalUnpivotedRecords.push(finalRecord);\n      } else {\n      }\n    } \n  } \n  \n  return finalUnpivotedRecords;\n}"]}