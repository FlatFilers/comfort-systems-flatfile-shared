{"version":3,"file":"record_processor.spec.js","sourceRoot":"","sources":["../../../../src/utils/federation/processors/record_processor.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { Flatfile } from \"@flatfile/api\";\nimport { createStandardRecord, processRecord } from \"./record_processor\";\nimport { createUnpivotedRecords } from \"./unpivot_processor\";\nimport { UnpivotGroupConfig, SourceMapping, FieldMapping, UnpivotMapping } from \"../../../types\";\n\n// Mock unpivot processor\njest.mock(\"./unpivot_processor\", () => ({\n  createUnpivotedRecords: jest.fn((recordValues: Record<string, any>, sourceSlug: string, unpivotGroups: Array<[string, UnpivotGroupConfig]>) => {\n    return [{\n      ...recordValues,\n      unpivoted: true\n    }];\n  })\n}));\n\n// Helper function to create test records\nconst createTestRecord = (values: Record<string, string>) => \n  Object.entries(values).reduce((acc, [key, value]) => ({\n  ...acc,\n  [key]: { value }\n}), {});\n\ndescribe(\"record_processor\", () => {\n  describe(\"createStandardRecord\", () => {\n    const recordValues = {\n      source_field1: { value: \"value1\" },\n      source_field2: { value: \"value2\" },\n      source_field3: { value: \"value3\" },\n      empty_field: { value: undefined }\n    };\n    \n    it(\"should map source fields to target fields\", () => {\n      const fields = new Map([\n        [\"source_field1\", \"target_field1\"],\n        [\"source_field2\", \"target_field2\"],\n        [\"source_field3\", \"target_field3\"]\n      ]);\n      \n      const result = createStandardRecord(recordValues, fields);\n      \n      expect(result).toEqual({\n        target_field1: { value: \"value1\" },\n        target_field2: { value: \"value2\" },\n        target_field3: { value: \"value3\" }\n      });\n    });\n    \n    it(\"should skip undefined values\", () => {\n      const fields = new Map([\n        [\"source_field1\", \"target_field1\"],\n        [\"empty_field\", \"target_empty\"],\n        [\"non_existent\", \"non_existent_target\"]\n      ]);\n      \n      const result = createStandardRecord(recordValues, fields);\n      \n      // The implementation puts undefined values into the target fields\n      expect(result).toHaveProperty(\"target_field1\");\n      expect(result?.target_field1.value).toBe(\"value1\");\n      \n      // The empty_field is included in the result, though its value is undefined\n      expect(result).toHaveProperty(\"target_empty\");\n      expect(result?.target_empty.value).toBeUndefined();\n      \n      // Non-existent field in the source is skipped in the target\n      expect(result).not.toHaveProperty(\"non_existent_target\");\n    });\n    \n    it(\"should return null if no valid mappings\", () => {\n      const fields = new Map([\n        [\"non_existent_field\", \"target_field\"],\n        [\"another_non_existent\", \"another_target\"]\n      ]);\n      \n      const result = createStandardRecord(recordValues, fields);\n      expect(result).toBeNull();\n    });\n    \n    describe(\"Error Handling\", () => {\n      it(\"should handle malformed record values\", () => {\n        const malformedValues = {\n          source_field1: \"not-an-object\", // Should be { value: \"something\" }\n          source_field2: null,\n          source_field3: undefined\n        };\n        \n        const fields = new Map([\n          [\"source_field1\", \"target_field1\"],\n          [\"source_field2\", \"target_field2\"],\n          [\"source_field3\", \"target_field3\"]\n        ]);\n        \n        // Our implementation actually tries to handle this case\n        const result = createStandardRecord(malformedValues as any, fields);\n        expect(result).toEqual({ target_field1: \"not-an-object\", target_field2: null });\n      });\n      \n      it(\"should handle circular references in record values\", () => {\n        const circularObj: any = { value: \"test\" };\n        circularObj.self = circularObj;\n        \n        const circularValues = {\n          source_field1: circularObj\n        };\n        \n        const fields = new Map([\n          [\"source_field1\", \"target_field1\"]\n        ]);\n        \n        const result = createStandardRecord(circularValues, fields);\n        // The circular reference is preserved in our implementation\n        expect(result).toBeDefined();\n        expect(result?.target_field1.value).toBe(\"test\");\n      });\n    });\n    \n    describe(\"Performance\", () => {\n      it(\"should handle large record sets efficiently\", () => {\n        const largeRecordValues = Array.from({ length: 1000 }, (_, i) => ({\n          [`field${i}`]: { value: `value${i}` }\n        })).reduce((acc, curr) => ({ ...acc, ...curr }), {});\n        \n        const fields = new Map(\n          Object.keys(largeRecordValues).map(key => [key, `target_${key}`])\n        );\n        \n        const start = performance.now();\n        const result = createStandardRecord(largeRecordValues, fields);\n        const end = performance.now();\n        \n        expect(result).toBeDefined();\n        expect(end - start).toBeLessThan(100); // Should process 1000 fields in less than 100ms\n      });\n      \n      it(\"should maintain performance with complex field mappings\", () => {\n        const complexRecordValues = {\n          ...createTestRecord({ field1: \"value1\" }),\n          nested: {\n            field2: { value: \"value2\" },\n            deeper: {\n              field3: { value: \"value3\" }\n            }\n          }\n        };\n        \n        const fields = new Map([\n          [\"field1\", \"target_field1\"],\n          [\"nested.field2\", \"target_field2\"],\n          [\"nested.deeper.field3\", \"target_field3\"]\n        ]);\n        \n        const start = performance.now();\n        const result = createStandardRecord(complexRecordValues as any, fields);\n        const end = performance.now();\n        \n        expect(result).toBeDefined();\n        expect(end - start).toBeLessThan(10); // Should process complex mappings in less than 10ms\n      });\n    });\n    \n    describe(\"Virtual Fields\", () => {\n      it(\"should map virtual fields in createStandardRecord\", () => {\n        const recordValues = {\n          source_field1: { value: \"value1\" },\n          virtual_source: { value: \"virtualValue\" }\n        };\n        // Map includes a virtual field\n        const fields = new Map([\n          [\"source_field1\", \"target_field1\"],\n          [\"virtual_source\", \"virtual_field\"]\n        ]);\n        const result = createStandardRecord(recordValues, fields);\n        expect(result).toEqual({\n          target_field1: { value: \"value1\" },\n          virtual_field: { value: \"virtualValue\" }\n        });\n      });\n      \n      it(\"should not include virtual field if missing in source\", () => {\n        const recordValues = {\n          source_field1: { value: \"value1\" }\n        };\n        const fields = new Map([\n          [\"source_field1\", \"target_field1\"],\n          [\"virtual_source\", \"virtual_field\"]\n        ]);\n        const result = createStandardRecord(recordValues, fields);\n        expect(result).toHaveProperty(\"target_field1\");\n        expect(result).not.toHaveProperty(\"virtual_field\");\n      });\n    });\n  });\n  \n  describe(\"processRecord\", () => {\n    const recordValues = {\n      source_field1: { value: \"value1\" },\n      source_field2: { value: \"value2\" }\n    };\n    \n    const fields = new Map([\n      [\"source_field1\", \"target_field1\"],\n      [\"source_field2\", \"target_field2\"]\n    ]);\n    \n    it(\"should process standard record when no unpivot config\", () => {\n      const fieldMapping = {\n        type: 'field' as const,\n        sheetId: 'sheet-id',\n        sheetSlug: 'sheet-slug',\n        fields,\n        filters: {}\n      };\n      \n      const result = processRecord(recordValues, \"source_sheet\", fieldMapping);\n      \n      expect(result.length).toBe(1);\n      expect(result[0]).toEqual({\n        target_field1: { value: \"value1\" },\n        target_field2: { value: \"value2\" }\n      });\n    });\n    \n    it(\"should process unpivot records when unpivot config is provided\", () => {\n      const recordValues = {\n        field1: { value: \"value1\" },\n        unpivot_field: { value: \"unpivot_value\" }\n      };\n      \n      const unpivotGroups: Array<[string, UnpivotGroupConfig]> = [\n        [\"group1\", {\n          source_sheet_slug: \"source_sheet\",\n          field_mappings: [{ \"target_unpivot\": \"unpivot_field\" }]\n        }]\n      ];\n      \n      const unpivotMapping = {\n        type: 'unpivot' as const,\n        sheetId: 'sheet-id',\n        sheetSlug: 'sheet-slug',\n        filters: {},\n        unpivotGroups\n      };\n      \n      const result = processRecord(recordValues, \"source_sheet\", unpivotMapping);\n      \n      expect(result.length).toBe(1);\n      expect(result[0]).toEqual({\n        field1: { value: \"value1\" },\n        unpivot_field: { value: \"unpivot_value\" },\n        unpivoted: true\n      });\n    });\n    \n    describe(\"Performance\", () => {\n      it(\"should process large batches of records efficiently\", () => {\n        const batchSize = 1000;\n        const recordValues = createTestRecord({ field1: \"value1\" });\n        \n        const fieldMapping = {\n          type: 'field' as const,\n          sheetId: 'sheet-id',\n          sheetSlug: 'sheet-slug',\n          fields: new Map([[\"field1\", \"target_field1\"]]),\n          filters: {}\n        };\n        \n        const start = performance.now();\n        const promises = Array(batchSize).fill(null).map(() => \n          processRecord(recordValues, \"source_sheet\", fieldMapping)\n      );\n      const results = promises.map(result => result);\n      const end = performance.now();\n      \n      // Should process 1000 records in under 100ms\n      expect(end - start).toBeLessThan(100);\n      expect(results.length).toBe(batchSize);\n      results.forEach(result => {\n        expect(result).toHaveLength(1);\n        expect(result[0]).toEqual({\n          target_field1: { value: \"value1\" }\n        });\n      });\n    });\n    \n    it(\"should maintain performance with complex unpivot configurations\", () => {\n      const recordValues = createTestRecord({ field1: \"value1\" });\n      \n      const unpivotGroups: Array<[string, UnpivotGroupConfig]> = [\n        [\"group1\", {\n          source_sheet_slug: \"source_sheet\",\n          field_mappings: Array.from({ length: 100 }, (_, i) => ({\n            [`target_field${i}`]: `source_field${i}`            }))\n          }]\n        ];\n        \n        const unpivotMapping = {\n          type: 'unpivot' as const,\n          sheetId: 'sheet-id',\n          sheetSlug: 'sheet-slug',\n          filters: {},\n          unpivotGroups\n        };\n        \n        const start = performance.now();\n        const result = processRecord(recordValues, \"source_sheet\", unpivotMapping);\n        const end = performance.now();\n        \n        expect(result).toBeDefined();\n        expect(end - start).toBeLessThan(100); // Should process complex unpivot in less than 100ms\n      });\n    });\n    \n    describe(\"Virtual Fields\", () => {\n      it(\"should attach virtual fields to each unpivoted record in processRecord\", () => {\n        // Mock createUnpivotedRecords to check virtual field propagation\n        const unpivotGroups: Array<[string, UnpivotGroupConfig]> = [\n          [\"group1\", {\n            source_sheet_slug: \"source_sheet\",\n            field_mappings: [\n              { \"target_unpivot\": \"unpivot_field\" }\n            ]\n          }]\n        ];\n        const mapping = {\n          type: 'unpivot' as const,\n          sheetId: 'sheet-id',\n          sheetSlug: 'sheet-slug',\n          filters: {},\n          unpivotGroups,\n          virtualFieldsMap: new Map([[\"virtual_source\", \"virtual_field\"]])\n        };\n        const recordValues = {\n          unpivot_field: { value: \"uv\" },\n          virtual_source: { value: \"vv\" }\n        };\n        // Patch the real createUnpivotedRecords to simulate virtual field logic\n        const { createUnpivotedRecords } = require(\"./unpivot_processor\");\n        createUnpivotedRecords.mockImplementation((rec: any, slug: string, groups: Array<[string, any]>, vMap?: Map<string, string>) => {\n          // Attach virtual fields to each unpivoted record\n          return [\n            {\n              target_unpivot: rec.unpivot_field,\n              ...(vMap && vMap.has(\"virtual_source\") ? { virtual_field: rec.virtual_source } : {})\n            }\n          ];\n        });\n        const result = processRecord(recordValues, \"source_sheet\", mapping);\n        expect(result.length).toBe(1);\n        expect(result[0]).toHaveProperty(\"target_unpivot\");\n        expect(result[0]).toHaveProperty(\"virtual_field\");\n        expect(result[0].virtual_field.value).toBe(\"vv\");\n      });\n    });\n  });\n}); \n"]}